OTACZANIE 3 NEW RELEASE 1.03 CRACKED && RELOADED ++!!!!!!!!!! (13.05)

1. UPDATES

** Napisano funkcje zapisujące do pliku dane w takiej postaci, jak chcieliście, czyli:
% sDensity muDensity
& sMax muMax
[
$ numiter
traj
ot1
ot2
]

** Zmieniono format punktów, wcześniej punkty miały rzeczywiste współrzędne w formie double, teraz natomiast korzystają z intów (x,y) takich, że:
x*sMax/(1 << sDensity) - jest rzeczywistym położeniem na osi s
y*muMax/(1 << muDensity) - jest rzeczywistym położeniem na osi mu

Nie wiem, czy to dobrze, bo punkty te musimy podawać do modelu, żeby policzył nam koszt przejścia, a być może model korzysta z wartości rzeczywistych i se ich sam nie przelicza ze współrzędnych na siatce.


2. WYWOŁYWANIE PROGRAMU

./Otaczanie3 -o input -o output


3. FORMAT DANYCH WEJŚCIOWYCH

Plik input powinien zawierać dwie linie danych dokładnie w tej kolejności:

% sDensity muDensity
& sMax muMax

gdzie sDensity, muDensity, sMax, muMax są typu integer. Ponadto może posiadać wszelkie komentarze, makrodefinicje i inne pierdoły, bo i tak na początku daję go na C Preprocesor. Trajektorię początkową dajemy na zero, jeżeli to źle, w ostatniej linii pliku wejściowego można dać nam również trajektorię początkową. Plik input.o3 jest wyłącznie do użytku aplikacji, nie należy go ruszać. Plik ''nowy_plik'' jest przykładowym plikiem wejściowym.


/////////////////////////////////////////////////////////////


OTACZANIE 3 NEW RELEASE 1.02 CRACKED ++!!!!!!!!!! (25.04)


1. WYKORZYSTANE KLASY

headery i src z zewnętrznych źródeł (grupa od modelu), zawierające używane prez nas klasy, które powinny być zastąpione ich najnowszymi wersjami:
 - point.h, point.src (Point) klasa punktu, korzystamy z niej do stworzenia własnej, rozszerzonej klasy punktu UWAGA!!! wymaga się, aby pola _x _y znajdowały się w zakresie protected (a nie private)
 - model.h, model.src (Model) Tworzymy obiekt tego typu, aby korzystać z metody zwracającej wartość kryterium. Jeżeli sposób z tworzeniem obiektu typu model w klasie reprezentującej algorytm otaczania jest wg was chujowe, możemy korzystać z samego wskaźnika na funkcję, która nam tą energię zwróci.


2. KOMPILACJA

Oprócz plików zawierających (Point) i (Model) do całości programu dokompilowane powinny być następujące moduły (headery i src). Wymagane flagi kompilatora i linkera można znaleźć w pliku Makefile:
 - ExtPoint: klasa punksu rozszerzonego o wartość kryterium
 - Otaczanie3: klasa reprezentująca algorytm otaczanie3
 
 
3. KORZYSTANIE Z ALGORYTMU

Metody publiczne klasy Otaczanie3, potrzebne do odpalenia algorytmu, opisane będą/są w dokumentacji. Przykład użycia klasy znajduje się w pliku Main.src

4. WEJŚCIE

Podawać należy wszystkie te motywy związane z siatką, czyli s_Max, mu_Max, gęstość punktów na osiach G, gdzie G jest taką liczbą całkowitą, że ilość punktów na przedziale [0,Max] równa jest 2^G. Podać też trzeba trajektorię początkową w formacie list<Point>. Jeśli trajektoria początkowa ma być wczytana z pliku, to trzeba se ją wczytać do list<Point> X, a następnie do klasy Otaczanie3 podać X

5. WYJŚCIE

Program generuje jakąś tam lokalnie optymalną trajektorię i może zapisać ją do pliku: 3 kolumny liczb double (x, y, wartość), czy tam (s,mu,wartość)
 

6. UWAGI

Jeżeli coś komuś nie na rękę, to proszę o sugestie, zwłaszcza odnośnie interfejsu. Jak będzie potrzeba, to listę możemy zwracać przez wartość/wskaźnik, albo cokolwiek, zamiast zapisywać do pliku. Tak samo możemy dopisać jakieś wczytywanie danych z pliku, no tylko w sumie po co?

Program wyrzuca na razie jakieś pierdoły do debugowania na wyjście. Potem się to skasuje.



==================================================

No spoko. Coś spróbujemy dzisiaj napisać (24.04)

==================================================

nic nie jest zrobione na razie

żebym pamiętał, jak dodać wszystkie nowinki:
rkmiec: Prosze, nie rob tego! W ten sposob mozesz w bardzo
prosty sposob nawrzucac, pelno binarek.
svn status |grep '?' |awk '{print $2}'| xargs svn add





